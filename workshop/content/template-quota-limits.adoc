## プロジェクトリクエストテンプレート、 クォータ、Limits
アプリケーション管理のベーシックラボでは、OpenShiftの基本的なビルディングブロックを扱いましたが、これらはすべて *プロジェクト* 内に含まれています。

OpenShiftでは、1つの *プロジェクト* 内で使用できるオブジェクトの数やリソース（CPU、メモリなど）を制限しません。
さらに、ユーザーは無制限に *プロジェクト* を作成することができます。制約のない世界やPOC型の環境では、それはそれでいいでしょう。
しかし、現実には少し制約をつける必要があります。

### 背景: プロジェクトリクエストテンプレート
ユーザーが `oc new-project` コマンドを呼び出すと、新しいプロジェクトのリクエストフローが開始されます。
このワークフローの中で、新たに要求されたプロジェクトを作成するためにデフォルトのプロジェクト *テンプレート* が処理されます。

#### デフォルトの プロジェクトリクエストテンプレート を見てみる

組み込みのデフォルトの *プロジェクトリクエストテンプレート* を表示するには、以下のコマンドを実行します。

[source,bash,role="execute"]
----
oc adm create-bootstrap-project-template -o yaml
----

このコマンドのYAML出力を調べると、下の方に表示されているこの *テンプレート* に関連した様々なパラメータがあることに気づくでしょう。

[source,bash]
----
...
parameters:
- name: PROJECT_NAME
- name: PROJECT_DISPLAYNAME
- name: PROJECT_DESCRIPTION
- name: PROJECT_ADMIN_USER
- name: PROJECT_REQUESTING_USER
...
----


次に、 `oc new-project` コマンドのヘルプ出力を見てみましょう:

[source,bash,role="execute"]
----
oc new-project -h
----

`oc new-project` に `--display-name` ディレクティブがあることに注意してください。
このオプションはデフォルトの *テンプレート* の出力で見た `PROJECT_DISPLAYNAME` パラメータに対応します。

`new-project` ワークフローでは、ユーザーがプロジェクト要求を満たすための情報を提供します。
OpenShiftはこの要求を許可すべきかどうかを決定します。（例えば、ユーザーは *プロジェクト* を作成する許可を持っているのか？このユーザーは *プロジェクト* を作りすぎてないか？)
もし、要求が許可できる場合は、 *テンプレート* を処理します。　

*テンプレート* で定義されているオブジェクトを見てみると、クォータや制限についての言及がないことに気づくでしょう。
今すぐ変更しましょう。

NOTE: *テンプレート* は、ユーザーに再利用可能な OpenShift のセットを強力なパラメーターで作成できるようにする強力なツールです。
これらはもっと複雑なで関連性の高いコンポーネントを OpenShift に素早くデプロイする事に使う事ができます。
また、あたなの組織の Software Development Lifecycle (SDLC)の有用な部品となりうるでしょう。
詳細な情報は以下で確認できます。

// FIXME: Need 4.0 template doc link here
link:https://docs.openshift.com/container-platform/3.11/dev_guide/templates.html[template
documentation^]. このエクササイズでは、 *テンプレート* の詳細については深掘りしません。


#### プロジェクトリクエストテンプレート を編集する
このラボでは実際にテンプレートの変更を行う必要はありません。-- 変更したものを既に作成済みです。
`cat`,`less`もしくは、好きなエディターを使って、変更を確認します。

*プロジェクトリクエストテンプレート* :

[source,bash,role="execute"]
----
cat {{ HOME_PATH }}/support/project_request_template.yaml
----

新たに2つのセクションが追加されましたので、注意してください。 *ResourceQuota* と *LimitRange* です。

### Background: ResourceQuota
The
// FIXME: 4.0 Doc Link Needed
link:https://docs.openshift.com/container-platform/3.11/admin_guide/quota.html[quota
documentation^] provides a great description of *ResourceQuota*:

----
リソースクォータは、ResourceQuotaオブジェクトによって定義され、プロジェクトごとの総リソース消費量を制限する制約を提供します。
これは、プロジェクト内で作成できるオブジェクトの量をタイプ別に制限したり、そのプロジェクト内のリソースが消費する計算リソースとストレージの総量を制限したりすることができます。
----

私たちの場合は、CPU, memory, storage, volume claims と *Pods* に特定のクォータを設定しています。
`project_request_template.yaml` ファイルの `ResourceQuota` セクションを見てみましょう。

[source,yaml]
----
- apiVersion: v1
  kind: ResourceQuota
  metadata:
    name: ${PROJECT_NAME}-quota <1>
  spec:
    hard:
      pods: 10 <2>
      requests.cpu: 4000m <3>
      requests.memory: 8Gi <4>
      resourcequotas: 1
      requests.storage: 50Gi <5>
      persistentvolumeclaims: 5 <6>
      {{ CNS_STORAGECLASS }}.storageclass.storage.k8s.io/requests.storage: 25Gi <7>
      {{ CNS_BLOCK_STORAGECLASS }}.storageclass.storage.k8s.io/persistentvolumeclaims: 0 <8>
----

<1> プロジェクト*には1つのクォータしか定義できませんが、そのクォータには一意の name/id が必要です。
<2> プロジェクト内に存在しうる non-terminal 状態のポッドの総数。
<3> CPUは「ミリコア」で計測されます。どのように Kubernetes/OpenShift がコアを計算するかは以下で確認できます。
link:https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/[upstream
documentation^].
<4> LIMITITS` と `REQUEST` の両方のシステムがありますが、これについては *LimitRange* オブジェクトを見てから詳しく説明します。
<5> プロジェクト内のすべての永続的なボリュームクレームにおいて、要求されたストレージの合計がこの値を超えることはできません。
<6> プロジェクト内の Persistent Volume クレームの総数。
<7> この設定は、`glusterfs-storage` *StorageClass* を使用してプロビジョニングできるストレージの量を制限します。
<8> この設定は、`{ CNS_BLOCK_STORAGECLASS }}`という **StorageClass** の **PersistentVolumeClaims** の数を制限します。
値が0の場合、このプロジェクトではこのストレージクラスから **PersistentVolumeClaims** を作成することはできません。

利用可能なクォータオプションの詳細については、以下を参照してください。
// FIXME: 4.0 Doc Link Needed
link:https://docs.openshift.com/container-platform/3.11/admin_guide/quota.html[quota
documentation^].

### Background: LimitRange
The
// FIXME: 4.0 Doc Link Needed
link:https://docs.openshift.com/container-platform/3.11/admin_guide/limits.html[limit
range documentation^] provides some good background:

----
LimitRangeオブジェクトで定義された制限範囲は、ポッド、コンテナ、イメージ、イメージストリーム、永続ボリューム クレームのレベルでプロジェクト内の計算リソース制約を列挙し、ポッド、コンテナ、イメージ、イメージストリーム、永続ボリューム クレームが消費できるリソースの量を指定します。

----

クォータはプロジェクト内の総資源消費量の上限を設定しますが、`LimitRange`は一般的に個々の資源に適用されます。
例えば、個々の *Pod* やコンテナがどれだけの CPU を使用できるかを設定することができます。

サンプルの `LimitRange` 定義を見てみましょう。

`project_request_template.yaml` ファイル:

[source,yaml]
----
- apiVersion: v1
  kind: LimitRange
  metadata:
    name: ${PROJECT_NAME}-limits
    creationTimestamp: null
  spec:
    limits:
      -
        type: Container
        max: <1>
          cpu: 4000m
          memory: 1024Mi
        min: <2>
          cpu: 10m
          memory: 5Mi
        default: <3>
          cpu: 4000m
          memory: 1024Mi
        defaultRequest: <4>
          cpu: 100m
          memory: 512Mi
----

リクエストとデフォルトの制限値の違いは重要で、それについてはこの中で説明しています。
link:https://docs.openshift.com/container-platform/3.11/admin_guide/limits.html[limit
range documentation^]. ですが、一般的には:

<1> `max`は制限やリクエストに指定できる最高の値である。
<2> `min`はリミットとリクエストに指定できる最低の値です。
<3> `default` は、何も指定されていない場合に、コンテナが消費できる最大量（制限）です。
<4> `defaultRequest` は何も指定されてない場合に、コンテナが消費する最小量です。

これらのトピックに加えて、 *Quality of Service Tiers* や *Limit* : *リクエスト* の比率 のようなものがあります。
以下のリンクにはさらに多くの情報があります。
link:https://docs.openshift.com/container-platform/3.11/dev_guide/compute_resources.html[compute
resources^] section of the documentation.

簡潔に言うと、OpenShiftにはサービス品質とリソース管理の複雑で強力なシステムが存在します。
クラスタで実行されるワークロードの種類を理解することは、これらすべての設定に賢明な値を設定するために重要です。

これらの例で提供している設定は、一般的に以下ようにプロジェクトを制限しています。：

* A total CPU quota of 4 cores (`4000m`) where
** Individual containers
*** must use 4 cores or less
*** cannot be defined with less than 10 milicores
*** will default to a request of 100 milicores (if not specified)
*** may burst up to a limit of 4 cores (if not specified)
* A total memory usage of 8 Gibibyte (8192 Megabytes) where
** Individual containers
*** must use 1 Gi or less
*** cannot be defined with less than 5 Mi
*** will default to a request of 512 Mi
*** may burst up to a limit of 1024 Mi
* Total storage claims of 25 Gi or less
* A total number of 5 volume claims
* 10 or less *Pods*

クォータと組み合わせることで、ユーザーが OpenShift の様々なリソースを要求し、利用する方法について、プロジェクト間でも非常に細かいコントロールを作成することができます。

NOTE: クォータと制限は、*プロジェクト* レベルで適用されることを覚えておいてください。
*ユーザー* は複数の *プロジェクト* にアクセスすることができますが、クォータと制限は *ユーザー* には直接適用されません。
複数の *プロジェクト* に1つのクォータを適用したい場合は、以下を見て下さい。
link:https://docs.openshift.com/container-platform/3.11/admin_guide/multiproject_quota.html[multi-project
quota^] documentation. これらの演習では、複数プロジェクトのクォータをカバーすることはありません。

### プロジェクトリクエストテンプレート をインストールする。
この背景を踏まえて、実際に OpenShift にこの新しい *プロジェクトリクエストテンプレート* を使用するように指示してみましょう。

#### Template を作成する
先ほど説明したように、 *テンプレート* はOpenShiftオブジェクトの別のタイプにすぎません。　
oc` コマンドは `create` 関数を提供し、YAML/JSON を入力として受け取り、提供されたオブジェクトを単純にインスタンス化します。

次に以下を実行します。:

[source,bash,role="execute"]
----
oc create -f {{ HOME_PATH }}/support/project_request_template.yaml -n openshift-config
----

これで、`openshift-config` *プロジェクト* 内に *テンプレート* オブジェクトが作成されます。
これで、`openshift-config` プロジェクト内の *テンプレート* が以下のように表示されるようになりました。:

[source,bash,role="execute"]
----
oc get template -n openshift-config
----

以下のようなものが表示されます。:

----
NAME              DESCRIPTION   PARAMETERS    OBJECTS
project-request                 5 (5 blank)   7
----

#### Setting the Default ProjectRequestTemplate
デフォルトの *projectRequestTemplate* はOpenShift API Serverの設定の一部です。
この設定は最終的に `openshift-apiserver` プロジェクト内の *ConfigMap* に格納されます。
API Serverの構成は、以下のコマンドで表示できます。:

[source,bash,role="execute"]
----
oc get cm config -n openshift-apiserver -o jsonpath --template="{.data.config\.yaml}" | jq
----

様々な *CustomResource* （CR）インスタンスを見て、定義したコンフィグレーションがクラスタに実装されていることを確認する OpenShift オペレーター があります。

言い換えれば、 オペレーターは最終的に *ConfigMap* の作成/変更を担当します。

jq`の出力を見ると、`projectRequestMessage`はありますが、`projectRequestTemplate`は定義されていません。

現在のところCRには何も指定されていないので、オペレータはクラスタを "標準(stock) "の設定で設定しています。

デフォルトのプロジェクトリクエストテンプレートの設定を追加するには、CRを作成する必要があります。 *CustomResource* は次のようになります。:

[source,yaml]
----
apiVersion: "config.openshift.io/v1"
kind: "Project"
metadata:
  name: "cluster"
  namespace: ""
spec:
  projectRequestMessage: ""
  projectRequestTemplate:
    name: "openshift-config/project-request"
----

*projectRequestTemplate* の名前が、以前に `openshift-config` プロジェクトで作成したテンプレートの名前と一致していることに注意してください。

次にこの *CustomResource* を作成します。
この *CR* が作成されると、OpenShiftのオペレータは *CR* に気付き、構成の変更を適用します。
この *CustomResource* を作成するには、次のコマンドを発行します。:

[source,bash,role="execute"]
----
oc apply -f {{ HOME_PATH }}/support/cr_project_request.yaml -n openshift-config
----

このコマンドを実行すると、OpenShift API Server の設定が運営者によって更新されます。
これは実装された構成を見ることで確認できます。:

[source,bash,role="execute"]
----
oc get cm config -n openshift-apiserver -o jsonpath --template="{.data.config\.yaml}" | jq
----

新しい *projectConfig* セクションに注目してください。:

[source,json]
----
...
  "kind": "OpenShiftAPIServerConfig",
  "projectConfig": {
    "projectRequestMessage": "",
    "projectRequestTemplate": "openshift-config/project-request"
  },
...
----

#### 新しいプロジェクトを作成する
新しいプロジェクトを作成する際に、 *Quota* と *LimitRange* が作成されているのがわかるはずです。
まず、`template-test`という新しいプロジェクトを作成します。:

[source,bash,role="execute"]
----
oc new-project template-test
----

そして、`describe`を使って、この*プロジェクトの*詳細を見てください:

[source,bash,role="execute"]
----
oc describe project template-test
----

出力は以下のような感じになります:

----
Name:		template-test
Created:	7 seconds ago
Labels:		<none>
Annotations:	openshift.io/description=
		openshift.io/display-name=
		openshift.io/requester=system:admin
		openshift.io/sa.scc.mcs=s0:c10,c0
		openshift.io/sa.scc.supplemental-groups=1000090000/10000
		openshift.io/sa.scc.uid-range=1000090000/10000
Display Name:	<none>
Description:	<none>
Status:		Active
Node Selector:	<none>
Quota:
	Name:										template-test-quota
	Resource									Used	Hard
	--------									----	----
	persistentvolumeclaims								0	5
	pods										0	10
	requests.cpu									0	4
	requests.memory									0	8Gi
	requests.storage								0	50Gi
	resourcequotas									0	1
Resource limits:
	Name:		template-test-limits
	Type		Resource	Min	Max	Default	Limit	Limit/Request
	----		--------	---	---	---	-----	-------------
	Container	memory		5Mi	1Gi	1Gi	1Gi	-
	Container	cpu		10m	4	4	4	-

----

[NOTE]
====
クォータとリソース制限のセクションが表示されていない場合は、あなたが早すぎた可能性があります。
オペレータは必要なことをすべて実行するのに時間がかかることを覚えておいてください。
マスターが新しい設定を読み込む前にプロジェクトを作成した可能性があります。
先に `oc delete project template-test` を削除して、しばらくしてから再作成してください。
====

また、 *Quota* と *LimitRange* オブジェクトが作成されたことがわかります：

[source,bash,role="execute"]
----
oc get quota -n template-test
----

以下のようなものが見えるはずです:

----
NAME                  CREATED AT
template-test-quota   2019-03-30T14:26:43Z
----

そして:

[source,bash,role="execute"]
----
oc get limitrange -n template-test
----

以下のようなものが見えるはずです:

----
NAME                   CREATED AT
template-test-limits   2018-10-24T19:19:40Z
----

注意: `project-request` テンプレートが `openshift-config` プロジェクト内に作成されていることを確認してください。
テンプレートを作成せずに OpenShift API サーバー設定で定義すると、新規プロジェクトの作成に失敗します。

### クリーンナップ
必要であれば、アプリケーション管理の基礎ラボのアプリケーションをこの `template-test` プロジェクトの中にデプロイして、 *Quota* と *LimitRange* がどのように適用されているかを観察することができます。
その際には、 *DeploymentConfig* や *Pod* などの JSON/YAML 出力 (`oc get ... -o yaml`) を必ず見てください。

続ける前に、先ほど作成した *プロジェクト* を削除してください:

[source,bash,role="execute"]
----
oc delete project template-test
----
